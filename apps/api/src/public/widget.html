<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voxora Chat</title>
    <script>
      (function(){
        const params = new URLSearchParams(location.search);
        const cfgParam = params.get('cfg');
        try { window.__VOXORA_WIDGET_CONFIG__ = cfgParam ? JSON.parse(atob(cfgParam)) : null; } catch {}
      })();
    </script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        height: 100vh;
        background: white;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Header */
      .chat-header {
        background: var(--vx-bg, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        color: white;
        padding: 16px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .header-content {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        overflow: hidden;
        flex-shrink: 0;
      }

      .avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
        display: block;
      }

      .header-info h3 {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 2px;
      }

      .header-info p {
        font-size: 12px;
        opacity: 0.9;
      }

      .minimize-btn {
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        padding: 8px;
        border-radius: 6px;
        transition: background 0.2s;
      }

      .minimize-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      /* Chat Container */
      .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Welcome Screen */
      .welcome-screen {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 20px 24px;
        background: #ffffff;
        overflow-y: auto;
        min-height: 0;
      }

      .welcome-header {
        text-align: center;
        margin-bottom: 24px;
        flex-shrink: 0;
      }

      .welcome-icon {
        width: 48px;
        height: 48px;
        background: var(--vx-accent, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
        color: white;
        font-weight: 600;
        font-size: 18px;
        overflow: hidden;
      }

      .welcome-icon img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 12px;
        display: block;
      }

      .welcome-screen h2 {
        font-size: 20px;
        color: #1f2937;
        margin-bottom: 6px;
        font-weight: 600;
      }

      .welcome-screen p {
        color: #6b7280;
        font-size: 14px;
        line-height: 1.4;
      }

      .start-chat-form {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .form-section {
        flex: 1;
        margin-bottom: 16px;
        overflow-y: auto;
        min-height: 0;
      }

      .form-group {
        margin-bottom: 16px;
        position: relative;
      }

      .form-group:last-of-type {
        margin-bottom: 0;
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 14px 16px;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        font-size: 15px;
        font-family: inherit;
        transition: all 0.2s ease;
        background: #ffffff;
        resize: none;
      }

      .form-group input:focus,
      .form-group textarea:focus {
        outline: none;
        border-color: var(--vx-accent-color, #667eea);
        box-shadow: 0 0 0 3px var(--vx-accent-08, rgba(102, 126, 234, 0.08));
      }

      .form-group input::placeholder,
      .form-group textarea::placeholder {
        color: #9ca3af;
        font-size: 15px;
      }

      .form-group.required::after {
        content: '*';
        color: #ef4444;
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 16px;
        pointer-events: none;
      }

      .form-group.textarea {
        margin-bottom: 0;
      }

      .form-group textarea {
        min-height: 70px;
        max-height: 100px;
        resize: vertical;
        padding-top: 12px;
        padding-bottom: 12px;
        line-height: 1.5;
      }

      .form-footer {
        padding-top: 16px;
        border-top: 1px solid #f3f4f6;
        flex-shrink: 0;
        margin-top: auto;
      }

      .start-btn {
        width: 100%;
        background: var(--vx-accent, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        color: white;
        border: none;
        padding: 16px 24px;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .start-btn:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px var(--vx-accent-25, rgba(102, 126, 234, 0.25));
      }

      .start-btn:active:not(:disabled) {
        transform: translateY(0);
      }

      .start-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .privacy-note {
        text-align: center;
        color: #9ca3af;
        font-size: 12px;
        margin-top: 16px;
        line-height: 1.4;
      }

      /* Chat Interface */
      .chat-interface {
        display: none;
        flex-direction: column;
        height: 100%;
      }

      .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        scroll-behavior: smooth;
      }

      .message {
        display: flex;
        margin-bottom: 16px;
        animation: messageSlide 0.3s ease-out;
      }

      .message.user {
        justify-content: flex-end;
      }

      .message-bubble {
        max-width: 80%;
        padding: 12px 16px;
        border-radius: 18px;
        font-size: 14px;
        line-height: 1.4;
        word-wrap: break-word;
      }

      .message.agent .message-bubble {
        background: #f1f3f4;
        color: #1a1a1a;
        border-bottom-left-radius: 6px;
      }

      .message.user .message-bubble {
        background: var(--vx-accent, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        color: white;
        border-bottom-right-radius: 6px;
      }

      .message-time {
        font-size: 11px;
        opacity: 0.6;
        margin-top: 4px;
        text-align: right;
      }

      .typing-indicator {
        display: none;
        padding: 16px 20px;
        color: #666;
        font-size: 14px;
        font-style: italic;
      }

      /* Input Area */
      .input-area {
        padding: 16px 20px;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
        flex-shrink: 0;
      }

      .input-container {
        display: flex;
        align-items: center;
        gap: 8px;
        background: white;
        border-radius: 24px;
        padding: 6px 6px 6px 16px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        border: 1px solid #e9ecef;
        min-height: 48px;
      }

      .message-input {
        flex: 1;
        border: none;
        outline: none;
        padding: 8px 0;
        font-size: 14px;
        line-height: 1.5;
        resize: none;
        max-height: 100px;
        overflow-y: auto;
        background: transparent;
        font-family: inherit;
      }

      .message-input::-webkit-scrollbar {
        display: none;
      }

      .message-input {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      .message-input::placeholder {
        color: #9ca3af;
      }

      .send-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: none;
        background: var(--vx-accent, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s;
        flex-shrink: 0;
      }

      .send-btn:hover {
        transform: scale(1.05);
      }

      .send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* Animations */
      @keyframes messageSlide {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Powered by */
      .powered-by {
        padding: 8px 20px;
        text-align: center;
        font-size: 11px;
        color: #9ca3af;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
      }

      .powered-by a {
        color: var(--vx-accent-color, #667eea);
        text-decoration: none;
      }

      /* Tab Navigation */
      .tab-navigation {
        display: flex;
        background: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
        padding: 0 20px;
      }

      .tab-btn {
        flex: 1;
        padding: 12px 16px;
        background: none;
        border: none;
        color: #6b7280;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        position: relative;
        transition: all 0.2s ease;
        border-bottom: 2px solid transparent;
      }

      .tab-btn.active {
        color: var(--vx-accent-color, #667eea);
        border-bottom-color: var(--vx-accent-color, #667eea);
      }

      .tab-btn:hover {
        color: var(--vx-accent-color, #667eea);
        background: rgba(102, 126, 234, 0.04);
      }

      /* Tab Content */
      .tab-content {
        display: none;
        flex: 1;
        flex-direction: column;
        overflow: hidden;
      }

      .tab-content.active {
        display: flex;
      }

      /* Recent Conversations */
      .recent-conversations {
        flex: 1;
        overflow-y: auto;
        padding: 16px 20px;
      }

      .conversation-item {
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        margin-bottom: 8px;
        border: 1px solid #e5e7eb;
        transition: all 0.2s ease;
        background: white;
      }

      .conversation-item:hover {
        border-color: var(--vx-accent-color, #667eea);
        background: rgba(102, 126, 234, 0.02);
      }

      .conversation-item.active {
        border-color: var(--vx-accent-color, #667eea);
        background: rgba(102, 126, 234, 0.05);
      }

      .conversation-title {
        font-size: 14px;
        font-weight: 500;
        color: #1f2937;
        margin-bottom: 4px;
        display: -webkit-box;
        -webkit-line-clamp: 1;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .conversation-preview {
        font-size: 12px;
        color: #6b7280;
        margin-bottom: 4px;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        line-height: 1.3;
      }

      .conversation-time {
        font-size: 11px;
        color: #9ca3af;
      }

      .no-conversations {
        text-align: center;
        padding: 40px 20px;
        color: #6b7280;
      }

      .no-conversations-icon {
        width: 48px;
        height: 48px;
        background: #f3f4f6;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
        color: #9ca3af;
      }

      /* Responsive adjustments */
      @media (max-width: 480px) {
        .tab-btn {
          padding: 10px 12px;
          font-size: 13px;
        }
        
        .recent-conversations {
          padding: 12px 16px;
        }
        
        .conversation-item {
          padding: 10px;
        }
      }

      /* Scrollbar */
      .messages-container::-webkit-scrollbar {
        width: 4px;
      }

      .messages-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .messages-container::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 2px;
      }

      .messages-container::-webkit-scrollbar-thumb:hover {
        background: #9ca3af;
      }

      /* Mobile adjustments */
      @media (max-width: 480px) {
        .chat-header {
          padding: 12px 16px;
        }

        .welcome-screen {
          padding: 16px 20px;
        }

        .messages-container {
          padding: 16px;
        }

        .input-area {
          padding: 12px 16px;
        }

        .form-group {
          margin-bottom: 12px;
        }

        .form-group textarea {
          min-height: 60px;
          max-height: 80px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Chat Header -->
    <div class="chat-header" id="vx-header">
      <div class="header-content">
        <div class="avatar" id="vx-avatar">V</div>
        <div class="header-info">
          <h3 id="vx-title">Voxora Support</h3>
          <p>We typically reply instantly</p>
        </div>
      </div>
  <button class="minimize-btn" id="vx-minimize">
        <svg
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
      </button>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-navigation">
      <button class="tab-btn active" data-tab="home">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px; vertical-align: -2px;">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
          <polyline points="9,22 9,12 15,12 15,22"></polyline>
        </svg>
        Home
      </button>
      <button class="tab-btn" data-tab="recent">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 6px; vertical-align: -2px;">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12,6 12,12 16,14"></polyline>
        </svg>
        Recent
      </button>
    </div>

  <!-- Chat Container -->
    <div class="chat-container">
      <!-- Home Tab Content -->
      <div class="tab-content active" id="homeTab">
        <!-- Welcome Screen -->
       

        <!-- Chat Interface -->
        <div class="chat-interface" id="chatInterface" style="display: flex;">
          <div class="messages-container" id="messagesContainer">
            <!-- Messages will be added here -->
          </div>
          <div class="typing-indicator" id="typingIndicator">
            Support is typing...
          </div>
          <div class="input-area">
            <div class="input-container">
              <textarea
                class="message-input"
                id="messageInput"
                placeholder="Type your message..."
                rows="1"
              ></textarea>
              <button class="send-btn" id="sendBtn">
                <svg
                  width="18"
                  height="18"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <line x1="22" y1="2" x2="11" y2="13"></line>
                  <polygon points="22,2 15,22 11,13 2,9"></polygon>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Recent Tab Content -->
      <div class="tab-content" id="recentTab">
        <div class="recent-conversations" id="recentConversations">
          <div class="no-conversations" id="noConversations">
            <div class="no-conversations-icon">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
              </svg>
            </div>
            <p>No recent conversations</p>
            <small>Start a new conversation to see your chat history here</small>
          </div>
        </div>
      </div>
    </div>

    <!-- Powered by -->
    <div class="powered-by">
      Powered by <a href="https://github.com/voxora-cloud" target="_blank">Voxora</a>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      // State management
      let chatId = null;
      let userName = "";
      let userEmail = "";
      let isConnected = false;
      let widgetToken = null;
      let voxoraPublicKey = null;
      let socket = null;
  let typingTimeout = null;
  let isTyping = false;

      // DOM elements
      const chatInterface = document.getElementById("chatInterface");
      const messagesContainer = document.getElementById("messagesContainer");
      const messageInput = document.getElementById("messageInput");
      const sendBtn = document.getElementById("sendBtn");
      const typingIndicator = document.getElementById("typingIndicator");

      // Tab elements
      const tabBtns = document.querySelectorAll('.tab-btn');
      const homeTab = document.getElementById('homeTab');
      const recentTab = document.getElementById('recentTab');
      const recentConversations = document.getElementById('recentConversations');
      const noConversations = document.getElementById('noConversations');

      // Local Storage Management
      const STORAGE_KEYS = {
        CONVERSATIONS: 'voxora_conversations',
        CURRENT_USER: 'voxora_current_user'
      };

      // Get conversations from localStorage
      function getStoredConversations() {
        try {
          const stored = localStorage.getItem(STORAGE_KEYS.CONVERSATIONS);
          return stored ? JSON.parse(stored) : [];
        } catch (error) {
          console.error('Error reading conversations from localStorage:', error);
          return [];
        }
      }

      // Save conversation to localStorage
      function saveConversationToStorage(conversation) {
        try {
          const conversations = getStoredConversations();
          const existingIndex = conversations.findIndex(c => c.id === conversation.id);
          
          if (existingIndex !== -1) {
            conversations[existingIndex] = { ...conversations[existingIndex], ...conversation };
          } else {
            conversations.unshift(conversation);
          }
          
          // Keep only last 50 conversations
          if (conversations.length > 50) {
            conversations.splice(50);
          }
          
          localStorage.setItem(STORAGE_KEYS.CONVERSATIONS, JSON.stringify(conversations));
          updateRecentConversations();
        } catch (error) {
          console.error('Error saving conversation to localStorage:', error);
        }
      }

      // Update conversation in storage
      function updateConversationInStorage(conversationId, updates) {
        try {
          const conversations = getStoredConversations();
          const conversation = conversations.find(c => c.id === conversationId);
          if (conversation) {
            Object.assign(conversation, updates);
            localStorage.setItem(STORAGE_KEYS.CONVERSATIONS, JSON.stringify(conversations));
            updateRecentConversations();
          }
        } catch (error) {
          console.error('Error updating conversation in localStorage:', error);
        }
      }

      // Tab switching functionality
      function switchTab(tabName) {
        // Update tab buttons
        tabBtns.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.tab === tabName);
        });

        // Update tab content
        homeTab.classList.toggle('active', tabName === 'home');
        recentTab.classList.toggle('active', tabName === 'recent');

        // Load recent conversations if switching to recent tab
        if (tabName === 'recent') {
          updateRecentConversations();
        }
      }

      // Update recent conversations display
      function updateRecentConversations() {
        const conversations = getStoredConversations();
        
        if (conversations.length === 0) {
          noConversations.style.display = 'block';
          return;
        }

        noConversations.style.display = 'none';
        
        // Clear existing conversation items (except no-conversations div)
        const existingItems = recentConversations.querySelectorAll('.conversation-item');
        existingItems.forEach(item => item.remove());

        // Add conversation items
        conversations.forEach(conversation => {
          const item = createConversationItem(conversation);
          recentConversations.insertBefore(item, noConversations);
        });
      }

      // Create conversation item element
      function createConversationItem(conversation) {
        const item = document.createElement('div');
        item.className = 'conversation-item';
        item.dataset.conversationId = conversation.id;
        
        const lastMessage = conversation.lastMessage || 'No messages yet';
        const truncatedMessage = lastMessage.length > 60 ? lastMessage.substring(0, 60) + '...' : lastMessage;
        const timeAgo = formatTimeAgo(new Date(conversation.updatedAt || conversation.createdAt));
        
        item.innerHTML = `
          <div class="conversation-title">${conversation.title || 'Chat conversation'}</div>
          <div class="conversation-preview">${truncatedMessage}</div>
          <div class="conversation-time">${timeAgo}</div>
        `;
        
        item.addEventListener('click', () => loadConversation(conversation.id));
        
        return item;
      }

      // Format time ago
      function formatTimeAgo(date) {
        const now = new Date();
        const diffInMs = now - date;
        const diffInMinutes = Math.floor(diffInMs / (1000 * 60));
        const diffInHours = Math.floor(diffInMinutes / 60);
        const diffInDays = Math.floor(diffInHours / 24);

        if (diffInMinutes < 1) return 'Just now';
        if (diffInMinutes < 60) return `${diffInMinutes}m ago`;
        if (diffInHours < 24) return `${diffInHours}h ago`;
        if (diffInDays < 7) return `${diffInDays}d ago`;
        return date.toLocaleDateString();
      }

      // Load conversation from storage
      function loadConversation(conversationId) {
        const conversations = getStoredConversations();
        const conversation = conversations.find(c => c.id === conversationId);
        
        if (!conversation) {
          console.error('Conversation not found:', conversationId);
          return;
        }

        // Set current chat ID and user info
        chatId = conversation.id;
        userName = conversation.userName || '';
        userEmail = conversation.userEmail || '';
        
        // Switch to home tab and show chat interface
        switchTab('home');
        welcomeScreen.style.display = 'none';
        chatInterface.style.display = 'flex';
        isConnected = true; // Set connection state
        
        // Focus on message input
        messageInput.focus();
        
        // Load messages
        loadMessagesFromStorage(conversationId);
        
        // Reconnect socket for this conversation
        if (socket) {
          socket.emit('join_conversation', chatId);
        } else if (widgetToken) {
          // Initialize socket if it doesn't exist but we have a token
          initializeSocket();
          // Join conversation after socket is initialized
          setTimeout(() => {
            if (socket) {
              socket.emit('join_conversation', chatId);
            }
          }, 1000);
        }
        
        // Update active conversation styling
        document.querySelectorAll('.conversation-item').forEach(item => {
          item.classList.toggle('active', item.dataset.conversationId === conversationId);
        });
      }

      // Load messages from storage
      function loadMessagesFromStorage(conversationId) {
        const conversations = getStoredConversations();
        const conversation = conversations.find(c => c.id === conversationId);
        
        if (conversation && conversation.messages) {
          messagesContainer.innerHTML = '';
          conversation.messages.forEach(message => {
            addMessageToUI(message.content, message.sender, message.timestamp);
          });
          scrollToBottom();
        }
      }

      // Add tab event listeners
      tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          switchTab(btn.dataset.tab);
        });
      });

      // Initialize recent conversations on load
      document.addEventListener('DOMContentLoaded', () => {
        updateRecentConversations();
      });

      // Initialize socket connection for widget users
      function initializeSocket() {
        // Only initialize if we have a token
        if (!widgetToken) {
          console.error('Missing widget token, cannot connect');
          return;
        }
        
        socket = io({
          auth: {
            token: widgetToken
          },
          transports: ['websocket', 'polling']
        });

        socket.on('connect_error', (err) => {
          console.error('Socket connection error:', err.message);
          
          // Auto refresh token on authentication errors
          if (err.message.includes('Authentication error') && voxoraPublicKey) {
            // Attempt to get a fresh token
            fetch(`/api/v1/widget/auth/token`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                voxoraPublicKey,
                origin: window.location.origin
              })
            })
            .then(response => response.json())
            .then(data => {
              if (data.success && data.data.token) {
                widgetToken = data.data.token;
                socket.disconnect();
                setTimeout(() => {
                  socket = io({
                    auth: { token: widgetToken },
                    transports: ['websocket', 'polling']
                  });
                }, 1000);
              }
            })
            .catch(() => {
              // Silent fail - don't spam the console in production
            });
          }
        });

        socket.on('connect', () => {
          console.log('Socket connected for widget user with ID:', socket.id);
          
          if (chatId) {
            console.log('Joining conversation:', chatId);
            socket.emit('join_conversation', chatId);
          }
        });

        socket.on('disconnect', () => {
          console.log('Socket disconnected');
        });

        socket.on('new_message', (data) => {
          if (data.conversationId !== chatId) return;
          // Ignore messages sent by this widget user (they are already optimistically rendered)
          if (data.message?.metadata?.source === 'widget') return;
          
          // Re-enable send button when we receive any new message
          sendBtn.disabled = false;
          
          const senderName = data.message?.metadata?.senderName || 'Support Agent';
          addMessage(data.message.content, "agent", senderName);
        });

        socket.on('agent_typing', (data) => {
          if (data.conversationId === chatId) {
            showTyping();
          }
        });

        socket.on('agent_stopped_typing', (data) => {
          if (data.conversationId === chatId) {
            hideTyping();
          }
        });

        // Removed system message on agent assignment to avoid dummy messages
        socket.on('conversation_assigned', (data) => {
          // Optionally handle UI state without adding a chat bubble
        });

        // Handle message sent acknowledgment
        socket.on('message_sent', (data) => {
          // Re-enable send button when message is acknowledged by server
          sendBtn.disabled = false;
        });
      }
      // JWT Authentication functions
      async function makeAuthenticatedRequest(url, options = {}) {
        const defaultHeaders = {
          'Content-Type': 'application/json',
        };

        if (widgetToken) {
          defaultHeaders.Authorization = `Bearer ${widgetToken}`;
        }

        const mergedOptions = {
          ...options,
          headers: {
            ...defaultHeaders,
            ...options.headers
          }
        };

        try {
          const response = await fetch(url, mergedOptions);
          
          if (response.status === 401 && widgetToken) {
            console.log('Widget token expired or invalid');
          }

          return response;
        } catch (error) {
          console.error('API request failed:', error);
          throw error;
        }
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", function () {
        const params = new URLSearchParams(window.location.search);
        voxoraPublicKey = params.get("voxoraPublicKey");
        widgetToken = params.get("token");

        
        setupEventListeners();
        // Bind minimize button without inline handler (CSP-friendly)
        var minBtn = document.getElementById('vx-minimize');
        if (minBtn) {
          minBtn.addEventListener('click', minimizeWidget);
        }
        adjustTextareaHeight();
        
        // Show chat interface directly (it's already visible in HTML)
        chatInterface.style.display = 'flex';
        
        // Add welcome messages with slight delays for natural feel
        setTimeout(function() {
          addMessage('Hi there! ðŸ‘‹', 'agent', 'Support Team');
        }, 300);
        
        setTimeout(function() {
          addMessage('Welcome to our support chat. How can we help you today?', 'agent', 'Support Team');
        }, 800);
        
        setTimeout(function() {
          addMessage('Feel free to ask us anything - we\'re here to assist you!', 'agent', 'Support Team');
          // Focus on input after all welcome messages
          messageInput.focus();
        }, 1300);
        
        initializeSocket();
      });

      function setupEventListeners() {
        // Message input
        messageInput.addEventListener("input", function () {
          adjustTextareaHeight();
          sendBtn.disabled = !this.value.trim();
          handleTypingChanged(this.value);
        });

        messageInput.addEventListener("keydown", function (e) {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        });

        // Send button
        sendBtn.addEventListener("click", sendMessage);

        // Stop typing on blur
        messageInput.addEventListener('blur', () => {
          typingStop();
        });
      }

      async function handleStartChat(e) {
        e.preventDefault();

        const formData = new FormData(e.target);
        const data = {
          name: formData.get("name"),
          email: formData.get("email"),
          phone: formData.get("phone"),
          subject: formData.get("subject") || "General Inquiry",
          message: formData.get("message"),
          voxoraPublicKey: voxoraPublicKey
        };

        startBtn.disabled = true;
        startBtn.textContent = "Sending...";

        try {
          // Create conversation via API with authentication
          const response = await makeAuthenticatedRequest("/api/v1/widget/conversations", {
            method: "POST",
            body: JSON.stringify(data),
          });

          if (response.ok) {
            const result = await response.json();
            chatId = result.data.conversationId
            userName = data.name;
            userEmail = data.email;

            // Save new conversation to localStorage
            const newConversation = {
              id: chatId,
              title: `Chat with ${userName}`,
              userName: userName,
              userEmail: userEmail,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              lastMessage: data.message || 'New conversation started',
              messages: []
            };
            saveConversationToStorage(newConversation);

            // Initialize socket connection if not already done
            if (!socket && widgetToken) {
              initializeSocket();
            }

            // Switch to chat interface
            showChatInterface();

            // Join the conversation room via socket
            if (socket) {
              socket.emit('join_conversation', chatId);
            }

            // Add initial message
            if (data.message) {
              addMessage(data.message, "user", userName);
              
              // Send the message via socket to agents
              if (socket) {
                socket.emit('send_message', {
                  conversationId: chatId,
                  content: data.message,
                  type: 'text',
                  metadata: {
                    senderName: userName,
                    senderEmail: userEmail,
                    source: 'widget'
                  }
                });
              }

              // Removed informational system message to avoid dummy messages
            }
          } else {
            throw new Error("Failed to start chat");
          }
        } catch (error) {
          console.error("Error starting chat:", error);
          alert(
            "Sorry, there was an error starting the chat. Please try again."
          );
        } finally {
          startBtn.disabled = false;
          startBtn.textContent = "Send message";
        }
      }

      function showChatInterface() {
        welcomeScreen.style.display = "none";
        chatInterface.style.display = "flex";
        messageInput.focus();
        isConnected = true;
        
        // Debug info
        console.log("Chat interface shown after form submission");
        if (socket) {
          console.log("Socket ID:", socket.id);
        }
      }

      function addMessage(text, type, senderName) {
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${type}`;

        const time = new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });

        messageDiv.innerHTML = `
        <div class="message-bubble">
          ${text}
          <div class="message-time">${time}</div>
        </div>
      `;

        messagesContainer.appendChild(messageDiv);
        scrollToBottom();

        // Save message to localStorage if we have a chat ID
        if (chatId) {
          saveMessageToStorage(text, type, senderName);
        }

        // Notify parent window of new message
        if (type === "agent" && window.parent) {
          window.parent.postMessage({ type: "NEW_MESSAGE", text }, "*");
        }
      }

      // Save message to localStorage
      function saveMessageToStorage(content, sender, senderName) {
        if (!chatId) return;

        try {
          const conversations = getStoredConversations();
          let conversation = conversations.find(c => c.id === chatId);
          
          if (!conversation) {
            // Create new conversation
            conversation = {
              id: chatId,
              title: `Chat with ${userName || 'User'}`,
              userName: userName,
              userEmail: userEmail,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              messages: []
            };
          }

          // Add message to conversation
          const message = {
            content: content,
            sender: sender,
            senderName: senderName,
            timestamp: new Date().toISOString()
          };

          if (!conversation.messages) {
            conversation.messages = [];
          }
          
          conversation.messages.push(message);
          conversation.lastMessage = content;
          conversation.updatedAt = new Date().toISOString();

          // Update or add conversation to storage
          saveConversationToStorage(conversation);
        } catch (error) {
          console.error('Error saving message to localStorage:', error);
        }
      }

      // Alias function for backward compatibility
      function addMessageToUI(content, sender, timestamp) {
        const senderName = sender === 'user' ? userName : 'Support Agent';
        addMessage(content, sender, senderName);
      }

      // Scroll messages container to bottom
      function scrollToBottom() {
        if (messagesContainer) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
      }

      async function sendMessage() {
        const text = messageInput.value.trim();
        console.log('Send message called:', { text, chatId, socket: !!socket });
        
        if (!text) {
          console.log('Cannot send message: missing text');
          return;
        }

        addMessage(text, "user", userName || "You");
        messageInput.value = "";
        adjustTextareaHeight();
        sendBtn.disabled = true;

        // Create conversation if this is the first message
        if (!chatId) {
          try {
            const data = {
              name: userName || "Anonymous",
              email: userEmail || "anonymous@widget.user",
              subject: "Chat Support",
              message: text,
              voxoraPublicKey: voxoraPublicKey
            };

            const response = await makeAuthenticatedRequest("/api/v1/widget/conversations", {
              method: "POST",
              body: JSON.stringify(data),
            });

            if (response.ok) {
              const result = await response.json();
              chatId = result.data.conversationId;
              userName = data.name;
              userEmail = data.email;
              isConnected = true;

              // Save new conversation to localStorage
              const newConversation = {
                id: chatId,
                title: `Chat with ${userName}`,
                userName: userName,
                userEmail: userEmail,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                lastMessage: text,
                messages: []
              };
              saveConversationToStorage(newConversation);

              // Initialize socket if not already done
              if (!socket && widgetToken) {
                initializeSocket();
              }

              // Join the conversation room via socket
              if (socket) {
                socket.emit('join_conversation', chatId);
              }

              // Send the message via socket
              if (socket && chatId) {
                socket.emit('send_message', {
                  conversationId: chatId,
                  content: text,
                  type: 'text',
                  metadata: {
                    senderName: userName,
                    senderEmail: userEmail,
                    source: 'widget'
                  }
                });
                typingStop();
              }

              // Re-enable send button after a short delay
              setTimeout(() => {
                sendBtn.disabled = false;
              }, 1000);
            } else {
              throw new Error("Failed to create conversation");
            }
          } catch (error) {
            console.error("Error creating conversation:", error);
            sendBtn.disabled = false;
          }
          return;
        }

        // Send message via socket for existing conversation
        if (socket && chatId) {
          socket.emit('send_message', {
            conversationId: chatId,
            content: text,
            type: 'text',
            metadata: {
              senderName: userName,
              senderEmail: userEmail,
              source: 'widget'
            }
          });
          // stop typing when message is sent
          typingStop();
          
          // Re-enable send button after a short delay
          setTimeout(() => {
            sendBtn.disabled = false;
          }, 1000);
        } else {
          console.error("Cannot send message: Socket or chatId not available");
          // Re-enable send button if there was an error
          sendBtn.disabled = false;
        }
      }

      // Remove unused sendMessageToServer function since we're using sockets now

      function showTyping() {
        typingIndicator.style.display = "block";
        scrollToBottom();
      }

      function hideTyping() {
        typingIndicator.style.display = "none";
      }

      function typingStart() {
        if (!socket || !chatId) return;
        if (!isTyping) {
          socket.emit('typing_start', { conversationId: chatId });
          isTyping = true;
        }
        if (typingTimeout) clearTimeout(typingTimeout);
        typingTimeout = setTimeout(typingStop, 1500);
      }

      function typingStop() {
        if (!socket || !chatId) return;
        if (isTyping) {
          socket.emit('typing_stop', { conversationId: chatId });
          isTyping = false;
        }
        if (typingTimeout) {
          clearTimeout(typingTimeout);
          typingTimeout = null;
        }
      }

      function handleTypingChanged(val) {
        if (!val || !val.trim()) {
          typingStop();
        } else {
          typingStart();
        }
      }

      function adjustTextareaHeight() {
        messageInput.style.height = "auto";
        messageInput.style.height =
          Math.min(messageInput.scrollHeight, 100) + "px";
      }

      function minimizeWidget() {
        if (window.parent) {
          window.parent.postMessage({ type: "MINIMIZE_WIDGET" }, "*");
        }
      }

      // Expose functions for parent window
      window.chatWidget = {
        addMessage,
        showTyping,
        hideTyping,
        sendMessage: (message) => {
          if (socket && chatId) {
            socket.emit('send_message', {
              conversationId: chatId,
              content: message,
              type: 'text',
              metadata: {
                senderName: userName,
                senderEmail: userEmail,
                source: 'widget'
              }
            });
          }
        },
        joinConversation: (conversationId) => {
          if (socket) {
            socket.emit('join_conversation', conversationId);
          }
        }
      };
    </script>
  <script>
    (function applyConfig(){
      var cfg = window.__VOXORA_WIDGET_CONFIG__;
      if (!cfg) return;
      console.log('Applying widget config:', cfg);
      var header = document.getElementById('vx-header');
      var title = document.getElementById('vx-title');
      var avatar = document.getElementById('vx-avatar');
      var welcomeIcon = document.getElementById('vx-welcome-icon');
      if (cfg.backgroundColor && header) {
        header.style.setProperty('--vx-bg', cfg.backgroundColor);
        document.documentElement.style.setProperty('--vx-accent', cfg.backgroundColor);
        document.documentElement.style.setProperty('--vx-accent-color', cfg.backgroundColor);
        // Derive translucent variants for focus/hover shadows
        try {
          var hex = cfg.backgroundColor.trim();
          // Support rgb/rgba or hex; for simplicity, fallback rgba if parsing fails
          var rgba08 = 'rgba(102, 126, 234, 0.08)';
          var rgba25 = 'rgba(102, 126, 234, 0.25)';
          if (hex.startsWith('#') && (hex.length === 7 || hex.length === 4)) {
            // naive hex to rgb
            var r,g,b;
            if (hex.length === 7) {
              r = parseInt(hex.slice(1,3),16);
              g = parseInt(hex.slice(3,5),16);
              b = parseInt(hex.slice(5,7),16);
            } else {
              r = parseInt(hex[1]+hex[1],16);
              g = parseInt(hex[2]+hex[2],16);
              b = parseInt(hex[3]+hex[3],16);
            }
            rgba08 = 'rgba(' + r + ',' + g + ',' + b + ',0.08)';
            rgba25 = 'rgba(' + r + ',' + g + ',' + b + ',0.25)';
          }
          document.documentElement.style.setProperty('--vx-accent-08', rgba08);
          document.documentElement.style.setProperty('--vx-accent-25', rgba25);
        } catch(e) {}
      }
      
      // Apply display name first
      if (cfg.displayName && title) {
        title.textContent = cfg.displayName;
      }
      
      // Apply logo if available (priority over initials)
      if (cfg.logoUrl) {
        console.log('Applying logo URL:', cfg.logoUrl);
        if (avatar) {
          avatar.innerHTML = '';
          var img = document.createElement('img');
          img.src = cfg.logoUrl;
          img.alt = (cfg.displayName || 'Logo') + ' logo';
          img.onerror = function() {
            console.error('Failed to load logo:', cfg.logoUrl);
            // Fallback to initials on error
            if (cfg.displayName) {
              avatar.textContent = cfg.displayName.split(' ').map(function(s){return s[0]}).join('').slice(0,2).toUpperCase();
            } else {
              avatar.textContent = 'V';
            }
          };
          img.onload = function() {
            console.log('Logo loaded successfully');
          };
          avatar.appendChild(img);
        }
        if (welcomeIcon) {
          welcomeIcon.innerHTML = '';
          var wimg = document.createElement('img');
          wimg.src = cfg.logoUrl;
          wimg.alt = (cfg.displayName || 'Logo') + ' logo';
          wimg.onerror = function() {
            if (cfg.displayName) {
              welcomeIcon.textContent = (cfg.displayName[0]||'V').toUpperCase();
            } else {
              welcomeIcon.textContent = 'V';
            }
          };
          welcomeIcon.appendChild(wimg);
        }
      } else if (cfg.displayName) {
        // No logo, use initials
        if (avatar) {
          var initials = cfg.displayName.split(' ').map(function(s){return s[0]}).join('').slice(0,2).toUpperCase();
          avatar.textContent = initials;
        }
        if (welcomeIcon) {
          welcomeIcon.textContent = (cfg.displayName[0]||'V').toUpperCase();
        }
      }
    })();
  </script>
  </body>
</html>
