<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voxora Chat</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* RC4: use height:100% on html+body so the widget fills the
         iframe exactly ‚Äî 100vh behaves inconsistently inside iframes
         across browsers (especially mobile Safari). */
      html {
        height: 100%;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        height: 100%;
        background: white;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Header */
      .chat-header {
        background: var(--vx-bg, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        color: white;
        padding: 16px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .header-content {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        overflow: hidden;
        flex-shrink: 0;
      }

      .avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
        display: block;
      }

      .header-info h3 {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 2px;
      }

      .header-info p {
        font-size: 12px;
        opacity: 0.9;
      }

      .minimize-btn {
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        padding: 8px;
        border-radius: 6px;
        transition: background 0.2s;
      }

      .minimize-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      /* Chat Container */
      .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* Welcome Screen */
      .welcome-screen {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 20px 24px;
        background: #ffffff;
        overflow-y: auto;
        min-height: 0;
      }

      .welcome-header {
        text-align: center;
        margin-bottom: 24px;
        flex-shrink: 0;
      }

      .welcome-icon {
        width: 48px;
        height: 48px;
        background: var(--vx-accent, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
        color: white;
        font-weight: 600;
        font-size: 18px;
        overflow: hidden;
      }

      .welcome-icon img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 12px;
        display: block;
      }

      .welcome-screen h2 {
        font-size: 20px;
        color: #1f2937;
        margin-bottom: 6px;
        font-weight: 600;
      }

      .welcome-screen p {
        color: #6b7280;
        font-size: 14px;
        line-height: 1.4;
      }

      .start-chat-form {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .form-section {
        flex: 1;
        margin-bottom: 16px;
        overflow-y: auto;
        min-height: 0;
      }

      .form-group {
        margin-bottom: 16px;
        position: relative;
      }

      .form-group:last-of-type {
        margin-bottom: 0;
      }

      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 14px 16px;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        font-size: 15px;
        font-family: inherit;
        transition: all 0.2s ease;
        background: #ffffff;
        resize: none;
      }

      .form-group input:focus,
      .form-group textarea:focus {
        outline: none;
        border-color: var(--vx-accent-color, #667eea);
        box-shadow: 0 0 0 3px var(--vx-accent-08, rgba(102, 126, 234, 0.08));
      }

      .form-group input::placeholder,
      .form-group textarea::placeholder {
        color: #9ca3af;
        font-size: 15px;
      }

      .form-group.required::after {
        content: '*';
        color: #ef4444;
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 16px;
        pointer-events: none;
      }

      .form-group.textarea {
        margin-bottom: 0;
      }

      .form-group textarea {
        min-height: 70px;
        max-height: 100px;
        resize: vertical;
        padding-top: 12px;
        padding-bottom: 12px;
        line-height: 1.5;
      }

      .form-footer {
        padding-top: 16px;
        border-top: 1px solid #f3f4f6;
        flex-shrink: 0;
        margin-top: auto;
      }

      .start-btn {
        width: 100%;
        background: var(--vx-accent, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        color: white;
        border: none;
        padding: 16px 24px;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .start-btn:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px var(--vx-accent-25, rgba(102, 126, 234, 0.25));
      }

      .start-btn:active:not(:disabled) {
        transform: translateY(0);
      }

      .start-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .privacy-note {
        text-align: center;
        color: #9ca3af;
        font-size: 12px;
        margin-top: 16px;
        line-height: 1.4;
      }

      /* Chat Interface */
      .chat-interface {
        display: none;
        flex-direction: column;
        flex: 1;
        min-height: 0;
        /* RC1: hard-clip so no child can push input-area off screen */
        overflow: hidden;
      }

      .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        /* RC2: explicit bottom gap so last message never hides behind input */
        padding-bottom: 24px;
        scroll-behavior: smooth;
        min-height: 0;
        /* RC3: disable browser scroll-anchoring ‚Äî it fights scrollTop=scrollHeight */
        overflow-anchor: none;
      }

      /* Custom scrollbar for messages */
      .messages-container::-webkit-scrollbar {
        width: 5px;
      }
      .messages-container::-webkit-scrollbar-track {
        background: transparent;
      }
      .messages-container::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 3px;
      }
      .messages-container::-webkit-scrollbar-thumb:hover {
        background: #9ca3af;
      }
      .messages-container {
        scrollbar-width: thin;
        scrollbar-color: #d1d5db transparent;
      }

      .message {
        display: flex;
        margin-bottom: 16px;
        animation: messageSlide 0.3s ease-out;
      }

      .message.user {
        justify-content: flex-end;
      }

      .message-bubble {
        max-width: 80%;
        padding: 12px 16px;
        border-radius: 18px;
        font-size: 14px;
        line-height: 1.4;
        word-wrap: break-word;
      }

      .message.agent .message-bubble {
        background: #f1f3f4;
        color: #1a1a1a;
        border-bottom-left-radius: 6px;
      }

      .message.user .message-bubble {
        background: var(--vx-accent, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        color: white;
        border-bottom-right-radius: 6px;
      }

      .message-time {
        font-size: 11px;
        opacity: 0.6;
        margin-top: 4px;
        text-align: right;
      }

      /* Markdown-rendered content inside agent bubbles */
      .message-bubble .md p          { margin: 0 0 8px; }
      .message-bubble .md p:last-child{ margin-bottom: 0; }
      .message-bubble .md strong     { font-weight: 600; }
      .message-bubble .md em         { font-style: italic; }
      .message-bubble .md code       { font-family: ui-monospace, monospace; font-size: 12px;
                                       background: rgba(0,0,0,0.08); border-radius: 3px; padding: 1px 5px; }
      .message-bubble .md pre        { background: rgba(0,0,0,0.07); border-radius: 6px; padding: 10px 12px;
                                       overflow-x: auto; margin: 6px 0; }
      .message-bubble .md pre code   { background: none; padding: 0; font-size: 12px; }
      .message-bubble .md ul         { margin: 6px 0; padding-left: 18px; }
      .message-bubble .md ol         { margin: 6px 0; padding-left: 18px; }
      .message-bubble .md li         { margin-bottom: 3px; }
      .message-bubble .md h1,
      .message-bubble .md h2,
      .message-bubble .md h3         { font-size: 14px; font-weight: 600; margin: 8px 0 4px; }
      .message-bubble .md hr         { border: none; border-top: 1px solid rgba(0,0,0,0.12); margin: 8px 0; }
      .message-bubble .md a          { color: inherit; text-decoration: underline; }

      .typing-indicator {
        display: none;
        padding: 16px 20px;
        color: #666;
        font-size: 14px;
        font-style: italic;
        /* RC1: prevent typing indicator from stealing height from messages */
        flex-shrink: 0;
      }

      /* Animated typing dots ‚Äî shown inside the message thread */
      .typing-dots {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 2px;
      }
      .typing-dots span {
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background: #9ca3af;
        animation: typingBounce 1.2s ease-in-out infinite;
      }
      .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
      .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
      @keyframes typingBounce {
        0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
        30%            { transform: translateY(-5px); opacity: 1; }
      }

      /* Blinking cursor shown while text is being typed */
      .typing-cursor::after {
        content: '|';
        display: inline;
        animation: cursorBlink 0.7s step-end infinite;
        color: #9ca3af;
        font-weight: 300;
        margin-left: 1px;
      }
      @keyframes cursorBlink {
        0%, 100% { opacity: 1; }
        50%       { opacity: 0; }
      }

      /* ‚îÄ‚îÄ System / escalation notices ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      /* Centered pill shown for system events (e.g. "Connecting you to an agent") */
      .system-notice {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin: 8px 0 16px;
        animation: messageSlide 0.3s ease-out;
      }
      .system-notice::before,
      .system-notice::after {
        content: '';
        flex: 1;
        height: 1px;
        background: #e5e7eb;
      }
      .system-notice span {
        font-size: 12px;
        color: #6b7280;
        background: #f3f4f6;
        border: 1px solid #e5e7eb;
        border-radius: 99px;
        padding: 3px 12px;
        white-space: nowrap;
        max-width: 240px;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* Card shown when a specific agent has been assigned */
      .handoff-card {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 8px 0 16px;
        background: #f0fdf4;
        border: 1px solid #bbf7d0;
        border-radius: 12px;
        padding: 10px 14px;
        font-size: 13px;
        color: #166534;
        animation: messageSlide 0.35s ease-out;
      }
      .handoff-card .handoff-icon {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: #22c55e;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        flex-shrink: 0;
      }
      .handoff-card .handoff-text strong {
        font-weight: 600;
        display: block;
      }
      .handoff-card .handoff-text span {
        opacity: 0.75;
        font-size: 12px;
      }
      .input-area {
        padding: 16px 20px;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
        flex-shrink: 0;
      }

      .input-container {
        display: flex;
        align-items: center;
        gap: 8px;
        background: white;
        border-radius: 24px;
        padding: 6px 6px 6px 16px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        border: 1px solid #e9ecef;
        min-height: 48px;
      }

      .message-input {
        flex: 1;
        border: none;
        outline: none;
        padding: 8px 0;
        font-size: 14px;
        line-height: 1.5;
        resize: none;
        max-height: 100px;
        overflow-y: auto;
        background: transparent;
        font-family: inherit;
      }

      .message-input::-webkit-scrollbar {
        display: none;
      }

      .message-input {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      .message-input::placeholder {
        color: #9ca3af;
      }

      .send-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border: none;
        background: var(--vx-accent, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s;
        flex-shrink: 0;
      }

      .send-btn:hover {
        transform: scale(1.05);
      }

      .send-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* Animations */
      @keyframes messageSlide {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Powered by */
      .powered-by {
        padding: 8px 20px;
        text-align: center;
        font-size: 11px;
        color: #9ca3af;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
      }

      .powered-by a {
        color: var(--vx-accent-color, #667eea);
        text-decoration: none;
      }

      /* Views (conversations list / chat) */
      .vx-view {
        display: none;
        flex: 1;
        flex-direction: column;
        overflow: hidden;
      }
      .vx-view.active {
        display: flex;
      }

      /* Conversations toolbar */
      .conversations-toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-bottom: 1px solid #e9ecef;
        background: #f8f9fa;
      }
      .conversations-title {
        font-size: 14px;
        font-weight: 600;
        color: #1f2937;
      }
      .new-chat-btn {
        padding: 6px 14px;
        background: var(--vx-accent-color, #667eea);
        color: white;
        border: none;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: opacity 0.2s;
      }
      .new-chat-btn:hover { opacity: 0.85; }

      /* Chat toolbar (back button row) */
      .chat-toolbar {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        border-bottom: 1px solid #e9ecef;
        background: #f8f9fa;
        /* RC1: toolbar must never shrink ‚Äî it is not scrollable content */
        flex-shrink: 0;
      }
      .back-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        background: none;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 13px;
        color: #374151;
        cursor: pointer;
        transition: background 0.15s;
      }
      .back-btn:hover { background: #e5e7eb; }

      /* Conversations list */
      .recent-conversations {
        flex: 1;
        overflow-y: auto;
        padding: 16px 20px;
      }

      .conversation-item {
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        margin-bottom: 8px;
        border: 1px solid #e5e7eb;
        transition: all 0.2s ease;
        background: white;
        position: relative;
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }

      .conversation-item:hover {
        border-color: var(--vx-accent-color, #667eea);
        background: rgba(102, 126, 234, 0.02);
      }

      .conversation-item:hover .conversation-delete {
        opacity: 1;
      }

      .conversation-item.active {
        border-color: var(--vx-accent-color, #667eea);
        background: rgba(102, 126, 234, 0.05);
      }

      .conversation-content {
        flex: 1;
        min-width: 0;
      }

      .conversation-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
      }

      .conversation-title {
        font-size: 14px;
        font-weight: 500;
        color: #1f2937;
        flex: 1;
        display: -webkit-box;
        -webkit-line-clamp: 1;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .conversation-preview {
        font-size: 12px;
        color: #6b7280;
        margin-bottom: 4px;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        line-height: 1.3;
      }

      .conversation-time {
        font-size: 11px;
        color: #9ca3af;
      }

      .conversation-delete {
        background: none;
        border: none;
        color: #ef4444;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 16px;
        font-weight: bold;
        opacity: 0;
        transition: all 0.2s ease;
        flex-shrink: 0;
        line-height: 1;
      }

      .conversation-delete:hover {
        background: #fee2e2;
        color: #dc2626;
      }

      .conversation-agent-info {
        font-size: 11px;
        color: #10b981;
        margin-top: 2px;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .conversation-agent-info::before {
        content: "‚óè";
        font-size: 8px;
      }

      .no-conversations {
        text-align: center;
        padding: 40px 20px;
        color: #6b7280;
      }

      .no-conversations-icon {
        width: 48px;
        height: 48px;
        background: #f3f4f6;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 16px;
        color: #9ca3af;
      }

      /* Responsive adjustments */
      @media (max-width: 480px) {
        .tab-btn {
          padding: 10px 12px;
          font-size: 13px;
        }
        
        .recent-conversations {
          padding: 12px 16px;
        }
        
        .conversation-item {
          padding: 10px;
        }
      }

      /* Scrollbar */
      .messages-container::-webkit-scrollbar {
        width: 4px;
      }

      .messages-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .messages-container::-webkit-scrollbar-thumb {
        background: #d1d5db;
        border-radius: 2px;
      }

      .messages-container::-webkit-scrollbar-thumb:hover {
        background: #9ca3af;
      }

      /* Mobile adjustments */
      @media (max-width: 480px) {
        .chat-header {
          padding: 12px 16px;
        }

        .welcome-screen {
          padding: 16px 20px;
        }

        .messages-container {
          padding: 16px;
        }

        .input-area {
          padding: 12px 16px;
        }

        .form-group {
          margin-bottom: 12px;
        }

        .form-group textarea {
          min-height: 60px;
          max-height: 80px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Chat Header -->
    <div class="chat-header" id="vx-header">
      <div class="header-content">
        <div class="avatar" id="vx-avatar">V</div>
        <div class="header-info">
          <h3 id="vx-title">Voxora Support</h3>
          <p>We typically reply instantly</p>
        </div>
      </div>
  <button class="minimize-btn" id="vx-minimize">
        <svg
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
      </button>
    </div>

  <!-- Chat Container -->
    <div class="chat-container">

      <!-- Conversations View (default) -->
      <div class="vx-view active" id="conversationsView">
        <div class="conversations-toolbar">
          <span class="conversations-title">Your conversations</span>
          <button class="new-chat-btn" id="newConversationBtn">+ New chat</button>
        </div>
        <div class="recent-conversations" id="recentConversations">
          <div class="no-conversations" id="noConversations">
            <div class="no-conversations-icon">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
              </svg>
            </div>
            <p>No conversations yet</p>
            <small>Tap <strong>+ New chat</strong> to get started</small>
          </div>
        </div>
      </div>

      <!-- Chat View -->
      <div class="vx-view" id="chatView">
        <div class="chat-toolbar">
          <button class="back-btn" id="backToConversations">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="15,18 9,12 15,6"></polyline></svg>
            Back
          </button>
        </div>
        <!-- Chat Interface -->
        <div class="chat-interface" id="chatInterface" style="display: flex;">
          <div class="messages-container" id="messagesContainer">
            <!-- Messages will be added here -->
          </div>
          <div class="typing-indicator" id="typingIndicator">
            Support is typing...
          </div>
          <div class="input-area">
            <div class="input-container">
              <textarea
                class="message-input"
                id="messageInput"
                placeholder="Type your message..."
                rows="1"
              ></textarea>
              <button class="send-btn" id="sendBtn">
                <svg
                  width="18"
                  height="18"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <line x1="22" y1="2" x2="11" y2="13"></line>
                  <polygon points="22,2 15,22 11,13 2,9"></polygon>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>

    </div>

    <!-- Powered by -->
    <div class="powered-by">
      Powered by <a href="https://github.com/voxora-cloud" target="_blank">Voxora</a>
    </div>

    <!-- Load Socket.IO from CDN since widget is now served from CDN -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js" crossorigin="anonymous"></script>
    <script>
      // Extract API URL from query params (passed from widget loader)
      const params = new URLSearchParams(window.location.search);
      const API_BASE_URL = params.get('apiUrl') || 'http://localhost:3002';
      
      // State management
      let chatId = null;
      let userName = "";
      let userEmail = "";
      let isConnected = false;
      let widgetToken = null;
      let voxoraPublicKey = null;
      let socket = null;
      let typingTimeout = null;
      let isTyping = false;

      // Cross-origin security: the parent page's origin, read from URL param.
      // All outbound postMessages are targeted at this origin (never '*').
      // All inbound postMessages are validated against this origin.
      let parentOrigin = null;

      // Unread message counter ‚Äî kept inside the iframe and reported to parent.
      let unreadCount = 0;

      // Timer that re-enables the input if INIT_WIDGET never arrives.
      let _connectTimeout = null;

      // Protocol version ‚Äî must match the loader's PROTOCOL_VERSION.
      const PROTO_VERSION = '1';

      // DOM elements
      const chatInterface = document.getElementById("chatInterface");
      const messagesContainer = document.getElementById("messagesContainer");
      const messageInput = document.getElementById("messageInput");
      const sendBtn = document.getElementById("sendBtn");
      const typingIndicator = document.getElementById("typingIndicator");

      // View elements
      const conversationsView = document.getElementById('conversationsView');
      const chatView = document.getElementById('chatView');
      const recentConversations = document.getElementById('recentConversations');
      const noConversations = document.getElementById('noConversations');

      // Cookie helpers for sessionId (works in sandboxed iframes)
      function setCookie(name, value, days) {
        const expires = new Date();
        expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
      }

      function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === ' ') c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
      }

      // Get sessionId from cookie or generate new one
      function getOrCreateSessionId() {
        try {
          // Try to get from cookie
          let sessionId = getCookie('voxora_session_id');
          if (sessionId) {
            console.log('üì± Session ID from cookie:', sessionId);
            return sessionId;
          }

          // Generate new sessionId
          sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Store in cookie
          setCookie('voxora_session_id', sessionId, 365);
          
          console.log('üì± New Session ID created:', sessionId);
          return sessionId;
        } catch (error) {
          console.error('Error managing sessionId:', error);
          // Generate temporary sessionId if all else fails
          return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
      }

      // SessionId will be set in DOMContentLoaded from URL params
      let currentSessionId = null;

      // Fetch conversations from backend
      async function fetchConversationsFromBackend() {
        if (!widgetToken || !currentSessionId) {
          console.warn('Cannot fetch conversations: missing token or sessionId');
          return [];
        }

        try {
          const response = await fetch(
            `${API_BASE_URL}/api/v1/widget/conversations?sessionId=${encodeURIComponent(currentSessionId)}`,
            {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${widgetToken}`
              }
            }
          );

          if (!response.ok) {
            console.error('Failed to fetch conversations:', response.status);
            return [];
          }

          const data = await response.json();
          const conversations = data.data?.conversations || [];
          
          console.log('‚úì Fetched conversations from backend:', conversations.length);
          
          return conversations;
        } catch (error) {
          console.error('Error fetching conversations from backend:', error);
          return [];
        }
      }

      // Fetch messages for a conversation from backend
      async function fetchMessagesFromBackend(conversationId) {
        if (!widgetToken || !currentSessionId) {
          console.warn('Cannot fetch messages: missing token or sessionId');
          return [];
        }

        try {
          const response = await fetch(
            `${API_BASE_URL}/api/v1/widget/conversations/${conversationId}/messages?sessionId=${encodeURIComponent(currentSessionId)}`,
            {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${widgetToken}`
              }
            }
          );

          if (!response.ok) {
            console.error('Failed to fetch messages:', response.status);
            return [];
          }

          const data = await response.json();
          return data.data?.messages || [];
        } catch (error) {
          console.error('Error fetching messages from backend:', error);
          return [];
        }
      }

      // View switching
      function showConversationsView() {
        conversationsView.classList.add('active');
        chatView.classList.remove('active');
        updateRecentConversations();
      }

      function showChatView() {
        chatView.classList.add('active');
        conversationsView.classList.remove('active');
      }

      // Update recent conversations display
      async function updateRecentConversations() {
        // Show loading state
        noConversations.textContent = 'Loading conversations...';
        noConversations.style.display = 'block';
        
        // Clear existing conversation items
        const existingItems = recentConversations.querySelectorAll('.conversation-item');
        existingItems.forEach(item => item.remove());

        try {
          // Fetch from backend
          const conversations = await fetchConversationsFromBackend();
          
          if (conversations.length === 0) {
            noConversations.textContent = 'No recent conversations';
            noConversations.style.display = 'block';
            return;
          }

          noConversations.style.display = 'none';

          // Add conversation items
          conversations.forEach(conversation => {
            const item = createConversationItem(conversation);
            recentConversations.insertBefore(item, noConversations);
          });
        } catch (error) {
          console.error('Error updating recent conversations:', error);
          noConversations.textContent = 'Failed to load conversations';
          noConversations.style.display = 'block';
        }
      }

      // Create conversation item element
      function createConversationItem(conversation) {
        const item = document.createElement('div');
        item.className = 'conversation-item';
        // Backend returns _id, not id
        const conversationId = conversation._id || conversation.id;
        item.dataset.conversationId = conversationId;
        
        const lastMessage = conversation.lastMessage?.content || conversation.lastMessage || 'No messages yet';
        const truncatedMessage = lastMessage.length > 60 ? lastMessage.substring(0, 60) + '...' : lastMessage;
        const timeAgo = formatTimeAgo(new Date(conversation.updatedAt || conversation.createdAt));
        const agentInfo = conversation.assignedAgent ? `<div class="conversation-agent-info">Agent: ${conversation.assignedAgent}</div>` : '';
        
        item.innerHTML = `
          <div class="conversation-content">
            <div class="conversation-header">
              <div class="conversation-title">${conversation.title || 'Chat conversation'}</div>
              <button class="conversation-delete" title="Delete conversation">√ó</button>
            </div>
            <div class="conversation-preview">${truncatedMessage}</div>
            ${agentInfo}
            <div class="conversation-time">${timeAgo}</div>
          </div>
        `;
        
        // Handle conversation click (not on delete button)
        const content = item.querySelector('.conversation-content');
        content.addEventListener('click', (e) => {
          if (!e.target.classList.contains('conversation-delete')) {
            loadConversation(conversationId);
          }
        });
        
        // Handle delete button
        const deleteBtn = item.querySelector('.conversation-delete');
        deleteBtn.addEventListener('click', async (e) => {
          e.stopPropagation();

          // Optimistically remove from the list immediately
          item.style.transition = 'opacity 0.2s';
          item.style.opacity = '0';

          try {
            const resp = await fetch(
              `${API_BASE_URL}/api/v1/widget/conversations/${conversationId}?sessionId=${encodeURIComponent(currentSessionId)}`,
              {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${widgetToken}` },
              }
            );
            if (resp.ok) {
              item.remove();
              // If this was the open conversation, go back to list
              if (chatId === conversationId) {
                chatId = null;
                isConnected = false;
                messagesContainer.innerHTML = '';
              }
              // Show empty-state if nothing left
              const remaining = recentConversations.querySelectorAll('.conversation-item');
              if (remaining.length === 0) {
                noConversations.textContent = 'No recent conversations';
                noConversations.style.display = 'block';
              }
            } else {
              // Rollback opacity on failure
              item.style.opacity = '1';
              console.error('Failed to delete conversation:', resp.status);
            }
          } catch (err) {
            item.style.opacity = '1';
            console.error('Error deleting conversation:', err);
          }
        });
        
        return item;
      }

      // Format time ago
      function formatTimeAgo(date) {
        const now = new Date();
        const diffInMs = now - date;
        const diffInMinutes = Math.floor(diffInMs / (1000 * 60));
        const diffInHours = Math.floor(diffInMinutes / 60);
        const diffInDays = Math.floor(diffInHours / 24);

        if (diffInMinutes < 1) return 'Just now';
        if (diffInMinutes < 60) return `${diffInMinutes}m ago`;
        if (diffInHours < 24) return `${diffInHours}h ago`;
        if (diffInDays < 7) return `${diffInDays}d ago`;
        return date.toLocaleDateString();
      }

      // Load conversation from storage
      async function loadConversation(conversationId) {
        try {
          // Show loading state
          messagesContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Loading conversation...</div>';

          // Set chatId directly ‚Äî no need to re-fetch the full conversations list
          // just to look up visitor info; the conversation was already visible in the
          // list so we can trust the ID and load messages straight away.
          chatId = conversationId;
          isConnected = true;

          console.log('Loading conversation:', conversationId);
          
          // Show chat view
          showChatView();
          chatInterface.style.display = 'flex';
          isConnected = true; // Set connection state
          
          // Focus on message input
          messageInput.focus();
          
          // Load messages from backend
          await loadMessagesFromBackend(chatId);
          
          // Reconnect socket for this conversation
          if (socket) {
            console.log('Rejoining conversation via socket:', chatId);
            socket.emit('join_conversation', chatId);
          } else if (widgetToken) {
            // Initialize socket if it doesn't exist but we have a token
            console.log('Initializing socket for resumed conversation');
            initializeSocket();
            // Join conversation after socket is initialized
            setTimeout(() => {
              if (socket) {
                console.log('Joining conversation after socket init:', chatId);
                socket.emit('join_conversation', chatId);
              }
            }, 1000);
          }
          
          // Update active conversation styling
          document.querySelectorAll('.conversation-item').forEach(item => {
            item.classList.toggle('active', item.dataset.conversationId === conversationId);
          });
        } catch (error) {
          console.error('Error loading conversation:', error);
          messagesContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #e74c3c;">Failed to load conversation</div>';
        }
      }

      // Load messages from backend
      async function loadMessagesFromBackend(conversationId) {
        try {
          messagesContainer.innerHTML = '';
          
          const messages = await fetchMessagesFromBackend(conversationId);
          
          if (messages.length === 0) {
            console.log('No messages found for conversation:', conversationId);
            return;
          }

          messages.forEach(message => {
            const sender = message.sender === 'visitor' ? 'user' : 'agent';
            addMessageToUI(message.content, sender, message.createdAt);
          });
          
          scrollToBottom();
          console.log(`‚úì Loaded ${messages.length} messages from backend`);
        } catch (error) {
          console.error('Error loading messages:', error);
          messagesContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #e74c3c;">Failed to load messages</div>';
        }
      }

      // Load messages from storage (fallback/cache)
      function loadMessagesFromStorage(conversationId) {
        const conversations = getStoredConversations();
        const conversation = conversations.find(c => c.id === conversationId);
        
        if (conversation && conversation.messages) {
          messagesContainer.innerHTML = '';
          conversation.messages.forEach(message => {
            addMessageToUI(message.content, message.sender, message.timestamp);
          });
          scrollToBottom();
        }
      }

      // Back button
      document.getElementById('backToConversations').addEventListener('click', showConversationsView);

      // New conversation button
      document.getElementById('newConversationBtn').addEventListener('click', function() {
        messagesContainer.innerHTML = '';
        chatId = null;
        isConnected = false;
        showChatView();
        messageInput.disabled = false;
        messageInput.placeholder = 'Type your message...';
        messageInput.focus();
        // Welcome messages for fresh conversation
        setTimeout(function() { addMessage('Hi there! üëã', 'agent', 'Support Team'); }, 150);
        setTimeout(function() { addMessage('How can we help you today?', 'agent', 'Support Team'); }, 500);
      });

      // Initialize socket connection for widget users
      function initializeSocket() {
        // Only initialize if we have a token
        if (!widgetToken) {
          console.error('Missing widget token, cannot connect');
          return;
        }
        
        socket = io(API_BASE_URL, {
          auth: {
            token: widgetToken
          },
          transports: ['websocket', 'polling']
        });

        socket.on('connect_error', (err) => {
          console.error('Socket connection error:', err.message);
          
          // Auto refresh token on authentication errors
          if (err.message.includes('Authentication error') && voxoraPublicKey) {
            // Attempt to get a fresh token
            fetch(`${API_BASE_URL}/api/v1/widget/auth/token`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                voxoraPublicKey,
                origin: window.location.origin
              })
            })
            .then(response => response.json())
            .then(data => {
              if (data.success && data.data.token) {
                widgetToken = data.data.token;
                socket.disconnect();
                setTimeout(() => {
                  socket = io(API_BASE_URL, {
                    auth: { token: widgetToken },
                    transports: ['websocket', 'polling']
                  });
                }, 1000);
              }
            })
            .catch(() => {
              // Silent fail - don't spam the console in production
            });
          }
        });

        socket.on('connect', () => {
          console.log('Socket connected for widget user with ID:', socket.id);
          
          if (chatId) {
            console.log('Joining conversation:', chatId);
            socket.emit('join_conversation', chatId);
          }
        });

        socket.on('disconnect', () => {
          console.log('Socket disconnected');
        });

        socket.on('new_message', (data) => {
          if (data.conversationId !== chatId) return;
          // Ignore messages sent by this widget user (already optimistically rendered)
          if (data.message?.metadata?.source === 'widget') return;

          // Re-enable send button
          sendBtn.disabled = false;

          // System messages (e.g. escalation notices) ‚Üí compact pill, not a chat bubble
          if (data.message?.metadata?.source === 'system') {
            removeTypingDots();
            addSystemNotice(data.message.content);
            return;
          }

          // Use animated typing effect for all incoming agent / AI messages
          typeMessage(data.message.content);
        });

        socket.on('agent_typing', (data) => {
          if (data.conversationId === chatId) {
            showTyping();
          }
        });

        socket.on('agent_stopped_typing', (data) => {
          if (data.conversationId === chatId) {
            hideTyping();
          }
        });

        // Removed system message on agent assignment to avoid dummy messages
        socket.on('conversation_assigned', (data) => {
          // Optionally handle UI state without adding a chat bubble
        });

        // Fired by the API when the AI escalates the conversation to a human agent.
        // We already received a system 'new_message' with the notice text, so here
        // we just clean up the typing state and show the handoff card if an agent
        // was assigned.
        socket.on('conversation_escalated', (data) => {
          if (data.conversationId !== chatId) return;
          removeTypingDots();
          sendBtn.disabled = false;
          if (data.agent?.name) {
            addHandoffCard(data.agent.name);
          }
        });

        // Handle message sent acknowledgment
        socket.on('message_sent', (data) => {
          // Re-enable send button when message is acknowledged by server
          sendBtn.disabled = false;
        });
      }
      // JWT Authentication functions
      async function makeAuthenticatedRequest(url, options = {}) {
        const defaultHeaders = {
          'Content-Type': 'application/json',
        };

        if (widgetToken) {
          defaultHeaders.Authorization = `Bearer ${widgetToken}`;
        }

        const mergedOptions = {
          ...options,
          headers: {
            ...defaultHeaders,
            ...options.headers
          }
        };

        try {
          const response = await fetch(url, mergedOptions);
          
          if (response.status === 401 && widgetToken) {
            console.log('Widget token expired or invalid');
          }

          return response;
        } catch (error) {
          console.error('API request failed:', error);
          throw error;
        }
      }

      // ‚îÄ‚îÄ‚îÄ Session bootstrap (iframe-domain localStorage) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      //
      // The iframe stores its own session in Voxora-domain localStorage.
      // This is fundamentally different from the parent-page (customer-domain)
      // localStorage that the loader manages. The browser enforces this
      // separation via the same-origin policy ‚Äî the iframe cannot read the
      // parent's storage even if it tried.
      //
      // Session key: voxora_sess_<publicKey>
      // Session shape: { token, expiresAt, sessionId, visitorId }
      //
      // On each page load:
      //   1. Loader sends INIT_WIDGET with visitorId
      //   2. iframe checks its own localStorage for a valid session
      //   3a. Valid: reuse stored token, reconnect WebSocket
      //   3b. Expired/missing: call backend auth endpoint, store new session
      //
      // This means the session survives: page reload, SPA navigation,
      // domain refresh, and iframe remount ‚Äî as long as the iframe origin
      // (widget.voxora.ai) localStorage hasn't been cleared.
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      function getSessionKey(pubKey) {
        return 'voxora_sess_' + pubKey;
      }

      function loadStoredSession(pubKey) {
        try {
          const raw = localStorage.getItem(getSessionKey(pubKey));
          if (!raw) return null;
          const s = JSON.parse(raw);
          // Validate shape and expiry (with a 30-second buffer)
          if (s && s.token && s.expiresAt && Date.now() < s.expiresAt - 30_000) {
            return s;
          }
          return null;
        } catch {
          return null;
        }
      }

      function persistSession(pubKey, token, expiresAt, sessionId, visitorId) {
        try {
          const data = JSON.stringify({ token, expiresAt, sessionId, visitorId });
          localStorage.setItem(getSessionKey(pubKey), data);
        } catch {
          // Silently ignore ‚Äî session won't persist but widget still works
        }
      }

      function clearStoredSession(pubKey) {
        try { localStorage.removeItem(getSessionKey(pubKey)); } catch {}
      }

      /**
       * Bootstrap the session:
       *   - Check iframe localStorage for a live session
       *   - If expired/missing: call backend auth endpoint
       *   - On success: store new session and call onReady(token, sessionId)
       *   - On failure: retry once, then show error state
       *
       * @param {object} initPayload  The INIT_WIDGET payload from the loader
       * @param {function} onReady    Called with (token, sessionId) when ready
       */
      async function bootstrapSession(initPayload, onReady) {
        const { publicKey, apiUrl, visitorId, identity } = initPayload;

        // Step 1: check iframe's own localStorage first (valid, unexpired token)
        const stored = loadStoredSession(publicKey);
        if (stored) {
          console.log('[VoxoraWidget] Resuming session from iframe localStorage');
          currentSessionId = stored.sessionId;
          onReady(stored.token, stored.sessionId);
          return;
        }

        // Step 1b: token may be expired but we still want to REUSE the same sessionId
        // so the user can see their previous conversations after re-auth.
        // Also honour visitorId (stable ID on the parent-page localStorage, forwarded
        // via INIT_WIDGET) as the primary anchor ‚Äî it survives iframe storage clears.
        let preservedSessionId = null;
        try {
          const raw = localStorage.getItem(getSessionKey(publicKey));
          if (raw) {
            const old = JSON.parse(raw);
            if (old?.sessionId) preservedSessionId = old.sessionId;
          }
        } catch {}

        // Step 2: no valid session ‚Äî obtain a fresh token from the backend
        console.log('[VoxoraWidget] Bootstrapping new session...');
        try {
          const body = {
            voxoraPublicKey: publicKey,
            // Pass the CUSTOMER's origin so the backend can validate the allowed domain.
            // This comes from the INIT_WIDGET payload, not window.location (which would
            // be the Voxora widget domain, not the customer's domain).
            origin: initPayload.pageUrl ? new URL(initPayload.pageUrl).origin : undefined,
          };
          if (identity && identity.userId) {
            body.userId    = identity.userId;
            body.userEmail = identity.email;
            body.userName  = identity.name;
          }

          const abortCtrl = new AbortController();
          const fetchTimeout = setTimeout(() => abortCtrl.abort(), 10_000);
          let res;
          try {
            res = await fetch(`${apiUrl}/api/v1/widget/auth/token`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body),
              credentials: 'omit',
              signal: abortCtrl.signal,
            });
          } finally {
            clearTimeout(fetchTimeout);
          }

          if (!res.ok) throw new Error(`Auth failed: ${res.status}`);

          const data = await res.json();
          if (!data.success || !data.data?.token) throw new Error('Invalid auth response');

          const token      = data.data.token;
          // Backend may return explicit expiry; default to 1 hour.
          const expiresAt  = data.data.expiresAt || (Date.now() + 60 * 60 * 1000);

          // Session ID priority:
          //   1. Backend-provided id  (future-proofing)
          //   2. visitorId from parent-page localStorage  ‚Äî stable across iframe clears
          //   3. Preserved id from our own expired localStorage entry  ‚Äî survives token refresh
          //   4. Fresh timestamp  ‚Äî first-ever visit, no anchor available
          const sessionId =
            data.data.sessionId ||
            (visitorId && visitorId.length > 4 ? visitorId : null) ||
            preservedSessionId ||
            ('sess_' + Date.now());

          persistSession(publicKey, token, expiresAt, sessionId, visitorId);

          currentSessionId = sessionId;
          onReady(token, sessionId);
        } catch (err) {
          console.error('[VoxoraWidget] Session bootstrap failed:', err);
          clearStoredSession(publicKey);
          // Re-enable the input so the user isn't stuck on "Connecting..." forever.
          // The widget will work for UI but live features (socket) won't be available.
          messageInput.disabled = false;
          messageInput.placeholder = 'Connection failed ‚Äî try refreshing';
          sendBtn.disabled = true;
        }
      }

      // ‚îÄ‚îÄ‚îÄ INIT_WIDGET / USER_IDENTITY / PAGE_CHANGE message handler ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      //
      // The iframe listens for structured postMessages from the loader.
      // Origin is validated against the `origin` URL param to prevent spoofing.
      //
      window.addEventListener('message', function(event) {
        // Validate origin against the parentOrigin we received at startup.
        // parentOrigin is set below in DOMContentLoaded from the URL param.
        if (parentOrigin && event.origin !== parentOrigin) return;

        const msg = event.data;
        if (!msg || !msg.type || msg.version !== PROTO_VERSION) return;

        switch (msg.type) {
          case 'INIT_WIDGET':
            handleInitWidget(msg.payload);
            break;

          case 'USER_IDENTITY':
            // User logged in/out on the host page after initial load.
            // Re-bootstrap session with the new identity.
            if (voxoraPublicKey && API_BASE_URL) {
              const refreshPayload = {
                publicKey: voxoraPublicKey,
                apiUrl: API_BASE_URL,
                visitorId: msg.payload.visitorId || '',
                identity: msg.payload,
                pageUrl: window.__voxoraPageUrl || '',
              };
              clearStoredSession(voxoraPublicKey);
              bootstrapSession(refreshPayload, function(token, sessionId) {
                widgetToken = token;
                currentSessionId = sessionId;
                if (socket) {
                  socket.disconnect();
                  socket = null;
                }
                initializeSocket();
              });
            }
            break;

          case 'PAGE_CHANGE':
            // SPA navigation on the host page
            window.__voxoraPageUrl = msg.payload.pageUrl;
            break;

          default:
            // Silently ignore unknown message types (forward compatibility)
            break;
        }
      });

      /**
       * Called once when INIT_WIDGET arrives from the loader.
       * This is the single entry point for the iframe startup sequence.
       */
      async function handleInitWidget(payload) {
        // Cancel the hard fallback timeout ‚Äî we've received INIT_WIDGET.
        if (_connectTimeout) { clearTimeout(_connectTimeout); _connectTimeout = null; }

        // API_BASE_URL is already set from the URL param `apiUrl` at page load
        // (see const API_BASE_URL below). We just keep publicKey in sync.
        voxoraPublicKey  = payload.publicKey;
        window.__voxoraPageUrl = payload.pageUrl;

        // Apply branding forwarded by the loader (avoids a duplicate API call)
        if (payload.appearance) {
          applyWidgetAppearance(payload.appearance);
        }

        // Boot the session from iframe localStorage or backend auth
        await bootstrapSession(payload, function(token, sessionId) {
          widgetToken      = token;
          currentSessionId = sessionId;

          // Now we have a valid token ‚Äî connect the WebSocket
          initializeSocket();

          // Re-enable the input now that we have a valid token
          messageInput.disabled = false;
          messageInput.placeholder = 'Type your message...';
          // sendBtn stays disabled until the user types something

          // Conversations are loaded by showConversationsView() below ‚Äî no need to call here.
        });

        // Show conversations list by default
        showConversationsView();
      }

      // ‚îÄ‚îÄ‚îÄ Widget appearance helper ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      function applyWidgetAppearance(cfg) {
        if (!cfg) return;
        var header       = document.getElementById('vx-header');
        var title        = document.getElementById('vx-title');
        var avatar       = document.getElementById('vx-avatar');
        var welcomeIcon  = document.getElementById('vx-welcome-icon');

        if (cfg.backgroundColor && header) {
          header.style.setProperty('--vx-bg', cfg.backgroundColor);
          document.documentElement.style.setProperty('--vx-accent', cfg.backgroundColor);
          document.documentElement.style.setProperty('--vx-accent-color', cfg.backgroundColor);
        }
        if (cfg.displayName && title) {
          title.textContent = cfg.displayName;
        }
        if (cfg.logoUrl) {
          if (avatar) {
            avatar.innerHTML = '';
            var img = document.createElement('img');
            img.src = cfg.logoUrl;
            img.alt = (cfg.displayName || 'Logo') + ' logo';
            img.onerror = function() {
              avatar.textContent = cfg.displayName ? cfg.displayName[0].toUpperCase() : 'V';
            };
            avatar.appendChild(img);
          }
          if (welcomeIcon) {
            welcomeIcon.innerHTML = '';
            var wimg = document.createElement('img');
            wimg.src = cfg.logoUrl;
            wimg.alt = (cfg.displayName || 'Logo') + ' logo';
            wimg.onerror = function() {
              welcomeIcon.textContent = cfg.displayName ? cfg.displayName[0].toUpperCase() : 'V';
            };
            welcomeIcon.appendChild(wimg);
          }
        } else if (cfg.displayName) {
          var initials = cfg.displayName.split(' ').map(function(s){return s[0];}).join('').slice(0,2).toUpperCase();
          if (avatar) avatar.textContent = initials;
          if (welcomeIcon) welcomeIcon.textContent = (cfg.displayName[0] || 'V').toUpperCase();
        }
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", function () {
        const params = new URLSearchParams(window.location.search);

        // Read parent origin and public key from URL params.
        // The token and sessionId are NO LONGER in the URL ‚Äî they come via
        // the INIT_WIDGET postMessage after WIDGET_READY handshake.
        parentOrigin     = params.get('origin') || null;
        voxoraPublicKey  = params.get('publicKey') || params.get('voxoraPublicKey') || null;

        setupEventListeners();

        // Bind minimize button
        var minBtn = document.getElementById('vx-minimize');
        if (minBtn) minBtn.addEventListener('click', minimizeWidget);

        adjustTextareaHeight();
        chatInterface.style.display = 'flex';

        // Disable input until widgetToken is ready (set by bootstrapSession).
        // This prevents the user from sending messages before authentication.
        messageInput.disabled = true;
        messageInput.placeholder = 'Connecting...';
        sendBtn.disabled = true;

        // Hard fallback: if INIT_WIDGET never arrives (loader blocked, CORS, etc.)
        // re-enable the input after 12 seconds so the widget isn't permanently frozen.
        _connectTimeout = setTimeout(function() {
          if (messageInput.disabled) {
            messageInput.disabled = false;
            messageInput.placeholder = 'Connection failed ‚Äî try refreshing';
            console.warn('[VoxoraWidget] INIT_WIDGET not received within 12s ‚Äî unblocking input');
          }
        }, 12000);

        // Signal to the loader that the iframe DOM is ready and
        // waiting for the INIT_WIDGET payload.
        //
        // The loader MUST NOT send INIT_WIDGET before this message arrives ‚Äî
        // otherwise the iframe's message listener won't be registered yet.
        //
        // Target the parent at parentOrigin for security; fall back to '*' only
        // in dev (parentOrigin is null only if origin param was missing).
        if (window.parent) {
          window.parent.postMessage(
            { type: 'WIDGET_READY', version: PROTO_VERSION },
            parentOrigin || '*'
          );
        }
      });

      function setupEventListeners() {
        // Message input
        messageInput.addEventListener("input", function () {
          adjustTextareaHeight();
          sendBtn.disabled = !this.value.trim();
          handleTypingChanged(this.value);
        });

        messageInput.addEventListener("keydown", function (e) {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
          }
        });

        // Send button
        sendBtn.addEventListener("click", sendMessage);

        // Stop typing on blur
        messageInput.addEventListener('blur', () => {
          typingStop();
        });
      }

      async function handleStartChat(e) {
        e.preventDefault();

        const formData = new FormData(e.target);
        const data = {
          message: formData.get("message"),
          voxoraPublicKey: voxoraPublicKey
        };

        startBtn.disabled = true;
        startBtn.textContent = "Sending...";

        try {
          // Create conversation via API with authentication
          const response = await makeAuthenticatedRequest(`${API_BASE_URL}/api/v1/widget/conversations`, {
            method: "POST",
            body: JSON.stringify(data),
          });

          if (response.ok) {
            const result = await response.json();
            chatId = result.data.conversationId

            // Initialize socket connection if not already done
            if (!socket && widgetToken) {
              initializeSocket();
            }

            // Switch to chat interface
            showChatInterface();

            // Join the conversation room via socket
            if (socket) {
              socket.emit('join_conversation', chatId);
            }

            // Add initial message
            if (data.message) {
              addMessage(data.message, "user", userName);
              
              // Send the message via socket to agents
              if (socket) {
                socket.emit('send_message', {
                  conversationId: chatId,
                  content: data.message,
                  type: 'text',
                  metadata: {
                    source: 'widget'
                  }
                });
              }

              // Removed informational system message to avoid dummy messages
            }
          } else {
            throw new Error("Failed to start chat");
          }
        } catch (error) {
          console.error("Error starting chat:", error);
          alert(
            "Sorry, there was an error starting the chat. Please try again."
          );
        } finally {
          startBtn.disabled = false;
          startBtn.textContent = "Send message";
        }
      }

      function showChatInterface() {
        showChatView();
        chatInterface.style.display = "flex";
        messageInput.focus();
        isConnected = true;
        
        // Debug info
        console.log("Chat interface shown after form submission");
        if (socket) {
          console.log("Socket ID:", socket.id);
        }
      }

      // ‚îÄ‚îÄ‚îÄ Tiny inline Markdown renderer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Handles the subset of Markdown the AI typically outputs.
      // Only applied to AGENT messages ‚Äî user messages are always plain-text escaped.
      function escapeHtml(str) {
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      }

      function parseMarkdown(text) {
        // Escape first, then selectively re-introduce HTML tags
        var s = escapeHtml(text);

        // Code blocks (``` ... ```)  ‚Äî must run before inline code
        s = s.replace(/```[\w]*\n?([\s\S]*?)```/g, function(_, code) {
          return '<pre><code>' + code.trim() + '</code></pre>';
        });

        // Inline code
        s = s.replace(/`([^`]+)`/g, '<code>$1</code>');

        // Markdown links [text](url) ‚Äî must run before bold/italic so parens aren't eaten
        s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g,
          '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');

        // Auto-link bare URLs that aren't already inside an href attribute
        s = s.replace(/(?<![="'(])https?:\/\/[^\s<>"')]+/g, function(url) {
          return '<a href="' + url + '" target="_blank" rel="noopener noreferrer">' + url + '</a>';
        });

        // Headers
        s = s.replace(/^### (.+)$/gm, '<h3>$1</h3>');
        s = s.replace(/^## (.+)$/gm, '<h2>$1</h2>');
        s = s.replace(/^# (.+)$/gm, '<h1>$1</h1>');

        // Bold + italic (order matters: bold-italic first)
        s = s.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
        s = s.replace(/\*\*(.+?)\*\*/g,     '<strong>$1</strong>');
        s = s.replace(/\*(.+?)\*/g,          '<em>$1</em>');
        s = s.replace(/__(.+?)__/g,          '<strong>$1</strong>');
        s = s.replace(/_(.+?)_/g,            '<em>$1</em>');

        // Horizontal rule
        s = s.replace(/^[-*]{3,}$/gm, '<hr>');

        // Unordered lists ‚Äî group consecutive items into <ul>
        s = s.replace(/((?:^[ \t]*[-*+] .+\n?)+)/gm, function(block) {
          var items = block.trim().split('\n').map(function(line) {
            return '<li>' + line.replace(/^[ \t]*[-*+] /, '') + '</li>';
          }).join('');
          return '<ul>' + items + '</ul>';
        });

        // Ordered lists ‚Äî group consecutive items into <ol>
        s = s.replace(/((?:^[ \t]*\d+\. .+\n?)+)/gm, function(block) {
          var items = block.trim().split('\n').map(function(line) {
            return '<li>' + line.replace(/^[ \t]*\d+\. /, '') + '</li>';
          }).join('');
          return '<ol>' + items + '</ol>';
        });

        // Paragraphs: blank-line separated blocks ‚Üí <p>
        s = s.replace(/\n{2,}/g, '</p><p>');
        // Remaining single newlines ‚Üí <br>
        s = s.replace(/\n/g, '<br>');
        // Wrap in a paragraph
        s = '<p>' + s + '</p>';
        // Clean up empty paragraphs
        s = s.replace(/<p>\s*<\/p>/g, '');

        return s;
      }

      // ‚îÄ‚îÄ Typing dots helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // A single reference to the dots bubble currently in the thread.
      // Only one can exist at a time.
      let _typingDotsEl = null;

      function showTypingDots() {
        if (_typingDotsEl) return; // already showing
        const wrapper = document.createElement('div');
        wrapper.className = 'message agent';
        wrapper.innerHTML = '<div class="message-bubble"><div class="typing-dots"><span></span><span></span><span></span></div></div>';
        _typingDotsEl = wrapper;
        messagesContainer.appendChild(wrapper);
        scrollToBottom();
      }

      function removeTypingDots() {
        if (_typingDotsEl) {
          _typingDotsEl.remove();
          _typingDotsEl = null;
        }
      }

      /**
       * addSystemNotice ‚Äî renders a centered pill-style divider for system events.
       * Used for messages like "Connecting you to a human agent‚Ä¶"
       */
      function addSystemNotice(text) {
        const el = document.createElement('div');
        el.className = 'system-notice';
        // Strip markdown bold markers for the compact pill label
        const plain = text.replace(/\*\*(.+?)\*\*/g, '$1');
        el.innerHTML = '<span>' + escapeHtml(plain) + '</span>';
        messagesContainer.appendChild(el);
        scrollToBottom();
      }

      /**
       * addHandoffCard ‚Äî renders a green card with agent name when a specific
       * agent has been assigned via escalation.
       */
      function addHandoffCard(agentName) {
        const el = document.createElement('div');
        el.className = 'handoff-card';
        el.innerHTML =
          '<div class="handoff-icon">üë§</div>' +
          '<div class="handoff-text">' +
            '<strong>' + escapeHtml(agentName) + '</strong>' +
            '<span>Human agent connected</span>' +
          '</div>';
        messagesContainer.appendChild(el);
        scrollToBottom();
      }

      /**
       * typeMessage ‚Äî animates an AI response into the chat thread.
       * Removes the pending dots bubble (shown on send), then types every
       * word with a small delay, finally renders full markdown.
       */
      function typeMessage(text) {
        // Remove the dots that were shown when the user sent their message
        removeTypingDots();

        const messageDiv = document.createElement('div');
        messageDiv.className = 'message agent';

        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';

        messageDiv.appendChild(bubble);
        messagesContainer.appendChild(messageDiv);
        scrollToBottom();

        const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        const words = text.split(' ');
        let wordIndex = 0;
        let accumulated = '';
        let contentEl = null;

        function typeNextWord() {
          if (wordIndex === 0) {
            contentEl = document.createElement('div');
            contentEl.className = 'md typing-cursor';
            bubble.innerHTML = '';
            bubble.appendChild(contentEl);
            const timePlaceholder = document.createElement('div');
            timePlaceholder.className = 'message-time';
            timePlaceholder.style.visibility = 'hidden';
            timePlaceholder.textContent = time;
            bubble.appendChild(timePlaceholder);
          }

          if (wordIndex < words.length) {
            accumulated += (wordIndex === 0 ? '' : ' ') + words[wordIndex];
            contentEl.textContent = accumulated;
            wordIndex++;
            scrollToBottom();
            setTimeout(typeNextWord, 28);
          } else {
            // Finalise: swap plain-text for rendered markdown
            contentEl.classList.remove('typing-cursor');
            contentEl.innerHTML = parseMarkdown(text);
            const timeEl = bubble.querySelector('.message-time');
            if (timeEl) { timeEl.style.visibility = ''; timeEl.textContent = time; }
            scrollToBottom();
            if (window.parent) {
              unreadCount++;
              window.parent.postMessage(
                { type: 'UNREAD_COUNT', version: PROTO_VERSION, payload: { count: unreadCount } },
                parentOrigin || '*'
              );
            }
          }
        }

        // Start typing immediately ‚Äî dots were already visible since send
        typeNextWord();
      }

      function addMessage(text, type, senderName) {
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${type}`;

        const time = new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });

        // Agent messages: render markdown. User messages: plain-text (HTML-escaped).
        const bodyHtml = type === 'agent'
          ? '<div class="md">' + parseMarkdown(text) + '</div>'
          : escapeHtml(text);

        messageDiv.innerHTML = `
        <div class="message-bubble">
          ${bodyHtml}
          <div class="message-time">${time}</div>
        </div>
      `;

        messagesContainer.appendChild(messageDiv);
        scrollToBottom();

        // Notify parent of unread message count when a new agent message arrives.
        // Uses UNREAD_COUNT protocol message (replaces the old NEW_MESSAGE).
        // The loader will render this number on the floating button badge.
        if (type === "agent" && window.parent) {
          unreadCount++;
          window.parent.postMessage(
            { type: 'UNREAD_COUNT', version: PROTO_VERSION, payload: { count: unreadCount } },
            parentOrigin || '*'
          );
        }
      }

      // Alias function for backward compatibility
      function addMessageToUI(content, sender, timestamp) {
        const senderName = sender === 'user' ? userName : 'Support Agent';
        addMessage(content, sender, senderName);
      }

      // Scroll messages container to bottom.
      // RC3: wrap in rAF so the DOM has painted the new message before
      // we read scrollHeight ‚Äî avoids stale measurements that leave
      // the last message partially off-screen.
      function scrollToBottom() {
        if (!messagesContainer) return;
        requestAnimationFrame(() => {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        });
      }

      async function sendMessage() {
        const text = messageInput.value.trim();
        if (!text) return;

        // Guard: token must be available before any API call.
        // bootstrapSession runs async after INIT_WIDGET arrives;
        // if the user somehow sends before it resolves, fail gracefully.
        if (!widgetToken) {
          console.warn('[VoxoraWidget] sendMessage called before token ready ‚Äî ignoring');
          return;
        }

        addMessage(text, "user", userName || "You");
        messageInput.value = "";
        adjustTextareaHeight();
        sendBtn.disabled = true;
        // Show typing dots immediately so the user knows the AI is working
        showTypingDots();

        // Create conversation if this is the first message
        if (!chatId) {
          try {
            const data = {
              // Field names must match widget schema: visitorName / visitorEmail
              visitorName: userName || undefined,
              visitorEmail: userEmail || undefined,
              message: text,
              voxoraPublicKey: voxoraPublicKey,
              sessionId: currentSessionId,
            };

            const response = await makeAuthenticatedRequest(`${API_BASE_URL}/api/v1/widget/conversations`, {
              method: "POST",
              body: JSON.stringify(data),
            });

            if (response.ok) {
              const result = await response.json();
              chatId = result.data.conversationId;
              userName = data.name;
              userEmail = data.email;
              isConnected = true;

              // Initialize socket if not already done
              if (!socket && widgetToken) {
                initializeSocket();
              }

              // Join the conversation room via socket
              if (socket) {
                socket.emit('join_conversation', chatId);
              }

              // Send the message via socket
              if (socket && chatId) {
                socket.emit('send_message', {
                  conversationId: chatId,
                  content: text,
                  type: 'text',
                  metadata: {
                    senderName: userName,
                    senderEmail: userEmail,
                    source: 'widget'
                  }
                });
                typingStop();
              }

              // Re-enable send button after a short delay
              setTimeout(() => {
                sendBtn.disabled = false;
              }, 1000);
            } else {
              removeTypingDots(); // clear dots on send failure
              throw new Error("Failed to create conversation");
            }
          } catch (error) {
            removeTypingDots();
            console.error("Error creating conversation:", error);
            sendBtn.disabled = false;
          }
          return;
        }

        // Send message via socket for existing conversation
        if (socket && chatId) {
          socket.emit('send_message', {
            conversationId: chatId,
            content: text,
            type: 'text',
            metadata: {
              senderName: userName,
              senderEmail: userEmail,
              source: 'widget'
            }
          });
          // stop typing when message is sent
          typingStop();
          
          // Re-enable send button after a short delay
          setTimeout(() => {
            sendBtn.disabled = false;
          }, 1000);
        } else {
          console.error("Cannot send message: Socket or chatId not available");
          // Re-enable send button if there was an error
          sendBtn.disabled = false;
        }
      }

      // Remove unused sendMessageToServer function since we're using sockets now

      function showTyping() {
        typingIndicator.style.display = "block";
        scrollToBottom();
      }

      function hideTyping() {
        typingIndicator.style.display = "none";
      }

      function typingStart() {
        if (!socket || !chatId) return;
        if (!isTyping) {
          socket.emit('typing_start', { conversationId: chatId });
          isTyping = true;
        }
        if (typingTimeout) clearTimeout(typingTimeout);
        typingTimeout = setTimeout(typingStop, 1500);
      }

      function typingStop() {
        if (!socket || !chatId) return;
        if (isTyping) {
          socket.emit('typing_stop', { conversationId: chatId });
          isTyping = false;
        }
        if (typingTimeout) {
          clearTimeout(typingTimeout);
          typingTimeout = null;
        }
      }

      function handleTypingChanged(val) {
        if (!val || !val.trim()) {
          typingStop();
        } else {
          typingStart();
        }
      }

      function adjustTextareaHeight() {
        messageInput.style.height = "auto";
        messageInput.style.height =
          Math.min(messageInput.scrollHeight, 100) + "px";
      }

      function minimizeWidget() {
        // Send CLOSE_WIDGET to parent using the known parentOrigin, never '*'.
        // Falls back to '*' only if parentOrigin is not yet set (shouldn't happen
        // after the INIT_WIDGET handshake, but avoids a silent failure in dev).
        const target = parentOrigin || '*';
        if (window.parent) {
          window.parent.postMessage(
            { type: 'CLOSE_WIDGET', version: PROTO_VERSION },
            target
          );
        }
      }

      // Expose functions for parent window
      window.chatWidget = {
        addMessage,
        showTyping,
        hideTyping,
        sendMessage: (message) => {
          if (socket && chatId) {
            socket.emit('send_message', {
              conversationId: chatId,
              content: message,
              type: 'text',
              metadata: {
                senderName: userName,
                senderEmail: userEmail,
                source: 'widget'
              }
            });
          }
        },
        joinConversation: (conversationId) => {
          if (socket) {
            socket.emit('join_conversation', conversationId);
          }
        }
      };
    </script>
  </body>
</html>
